// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Caml_array from "bs-platform/lib/es6/caml_array.js";

function merge_sort(t) {
  var sort = function (start, length) {
    if (length === 0) {
      return [];
    }
    if (length === 1) {
      return [Caml_array.get(t, start)];
    }
    var length1 = length / 2 | 0;
    var start2 = start + length1 | 0;
    var length2 = length - length1 | 0;
    var t1 = sort(start, length1);
    var t2 = sort(start2, length2);
    var out = Caml_array.caml_make_vect(length1 + length2 | 0, 0);
    var pos1 = 0;
    var pos2 = 0;
    while(pos1 < length1 || pos2 < length2) {
      var pos = pos1 + pos2 | 0;
      if (pos1 === length1) {
        Caml_array.set(out, pos, Caml_array.get(t2, pos2));
        pos2 = pos2 + 1 | 0;
      } else if (pos2 === length2 || Caml_array.get(t1, pos1) < Caml_array.get(t2, pos2)) {
        Caml_array.set(out, pos, Caml_array.get(t1, pos1));
        pos1 = pos1 + 1 | 0;
      }
      
    };
    return out;
  };
  var size = t.length;
  return $$Array.blit(sort(0, size), 0, t, 0, size);
}

function split(l) {
  var _source = l;
  var _left = /* [] */0;
  var _right = l;
  while(true) {
    var right = _right;
    var left = _left;
    var source = _source;
    if (!source) {
      return [
              left,
              right
            ];
    }
    var match = source.tl;
    if (!match) {
      return [
              left,
              right
            ];
    }
    if (right) {
      _right = right.tl;
      _left = {
        hd: right.hd,
        tl: left
      };
      _source = match.tl;
      continue ;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "MergeSort.re",
            47,
            11
          ],
          Error: new Error()
        };
  };
}

function split2(l) {
  return function (param) {
    var _source = l;
    var _left = /* [] */0;
    var _right = param;
    while(true) {
      var right = _right;
      var left = _left;
      var source = _source;
      if (!source) {
        return [
                left,
                right
              ];
      }
      _right = {
        hd: source.hd,
        tl: left
      };
      _left = right;
      _source = source.tl;
      continue ;
    };
  };
}

function r_merge_sort(l) {
  var merge = function (l1, l2) {
    if (!l1) {
      return l2;
    }
    if (!l2) {
      return l1;
    }
    var t2 = l2.tl;
    var h2 = l2.hd;
    var t1 = l1.tl;
    var h1 = l1.hd;
    if (Caml_obj.caml_lessthan(h1, h2)) {
      return {
              hd: h1,
              tl: merge(t1, {
                    hd: h2,
                    tl: t2
                  })
            };
    } else {
      return {
              hd: h2,
              tl: merge({
                    hd: h1,
                    tl: t1
                  }, t2)
            };
    }
  };
  var sort = function (sorted) {
    if (!sorted) {
      return sorted;
    }
    if (!sorted.tl) {
      return sorted;
    }
    var match = split(sorted);
    return merge(sort(match[0]), sort(match[1]));
  };
  sort(l);
  
}

function tr_merge_sort(l) {
  var merge = function (l1, l2) {
    var _merge = function (_l1, _l2, _result) {
      while(true) {
        var result = _result;
        var l2 = _l2;
        var l1 = _l1;
        if (l1) {
          var t1 = l1.tl;
          var h1 = l1.hd;
          if (l2) {
            var h2 = l2.hd;
            if (Caml_obj.caml_lessthan(h1, h2)) {
              _result = {
                hd: h1,
                tl: result
              };
              _l1 = t1;
              continue ;
            }
            _result = {
              hd: h2,
              tl: result
            };
            _l2 = l2.tl;
            continue ;
          }
          _result = {
            hd: h1,
            tl: result
          };
          _l2 = t1;
          _l1 = /* [] */0;
          continue ;
        }
        if (!l2) {
          return result;
        }
        _result = {
          hd: l2.hd,
          tl: result
        };
        _l2 = l2.tl;
        _l1 = /* [] */0;
        continue ;
      };
    };
    return List.rev(_merge(l1, l2, /* [] */0));
  };
  var sort = function (_l, _merge_fn) {
    while(true) {
      var merge_fn = _merge_fn;
      var l = _l;
      if (!l) {
        return Curry._1(merge_fn, l);
      }
      if (!l.tl) {
        return Curry._1(merge_fn, l);
      }
      var match = split(l);
      var right = match[1];
      _merge_fn = (function(merge_fn,right){
      return function (leftR) {
        return sort(right, (function (rightR) {
                      return Curry._1(merge_fn, merge(leftR, rightR));
                    }));
      }
      }(merge_fn,right));
      _l = match[0];
      continue ;
    };
  };
  sort(l, (function (x) {
          return x;
        }));
  
}

export {
  merge_sort ,
  split ,
  split2 ,
  r_merge_sort ,
  tr_merge_sort ,
  
}
/* No side effect */
